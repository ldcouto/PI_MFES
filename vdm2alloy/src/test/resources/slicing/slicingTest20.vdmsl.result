"module colMap
 definitions
private static  Country = Country
private static  Relation = Relation
	inv r == isRelation(r)
private static  Colour = Colour
private static  Colouring = Colouring
private static  private static isRelation: (Relation -> bool)
	isRelation(r) ==
(forall mk_(c1, c2) in set r & (c1 <> c2))
private static  private static areNb: (Country * Country * Relation -> bool)
	areNb(cn1, cn2, r) ==
((mk_(cn1, cn2) in set r) or (mk_(cn2, cn1) in set r))
private static  private static CountriesRel: (Relation -> set of (Country))
	CountriesRel(r) ==
(dunion {{c1, c2} | mk_(c1, c2) in set r})
private static  private static sameColour: (Country * Country * Colouring -> bool)
	sameColour(cn1, cn2, cols) ==
(exists col in set cols & ((cn1 in set col) and (cn2 in set col)))
private static  private static CountriesCol: (Colouring -> set of (Country))
	CountriesCol(cols) ==
(dunion cols)
private static  private static isColouring: (Colouring -> bool)
	isColouring(cols) ==
(forall col1, col2 in set cols & ((col1 <> col2) => ((col1 inter col2) = {})))
private static  private static isColouringOf: (Colouring * set of (Country) -> bool)
	isColouringOf(cols, cns) ==
(CountriesCol(cols) = cns)
private static  private static nbDistinctColours: (Colouring * Relation -> bool)
	nbDistinctColours(cols, r) ==
(forall cn1, cn2 in set CountriesRel(r) & (areNb(cn1, cn2, r) => (not sameColour(cn1, cn2, cols))))
private static  private static  colMap((r:Relation))cols:Colouring
	pre isRelation(r)
	post (isColouring(cols) and (isColouringOf(cols, CountriesRel(r)) and nbDistinctColours(cols, r)))
end colMap
"