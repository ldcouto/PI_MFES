types

  Country = seq of char;

  Relation = set of (Country * Country)
  inv r== isRelation(r);

  Colour = set of Country;

  Colouring = set of Colour;

functions

  isRelation: Relation -> bool
  isRelation(r) ==
    forall mk_(c1,c2) in set r & c1 <> c2;

  areNb: Country * Country * Relation -> bool
  areNb(cn1,cn2,r) ==
    mk_(cn1,cn2) in set r or mk_(cn2,cn1) in set r;

  CountriesRel: Relation -> set of Country
  CountriesRel(r) ==
    dunion {{c1,c2} | mk_(c1,c2) in set r};

  sameColour: Country * Country * Colouring -> bool
  sameColour(cn1,cn2,cols) ==
    exists col in set cols & cn1 in set col and cn2 in set col;

  CountriesCol: Colouring -> set of Country
  CountriesCol(cols) ==
    dunion cols;

  isColouring: Colouring -> bool
  isColouring(cols) ==
    forall col1,col2 in set cols & col1 <> col2 => col1 inter col2 = {};

  isColouringOf: Colouring * set of Country -> bool
  isColouringOf(cols,cns) ==
    CountriesCol(cols) = cns;

  nbDistinctColours: Colouring * Relation -> bool
  nbDistinctColours(cols,r) ==
    forall cn1, cn2 in set CountriesRel(r) &
           areNb(cn1,cn2,r) => not sameColour(cn1,cn2,cols);

  colMap(r: Relation) cols : Colouring 
  pre isRelation(r)
  post isColouring(cols) and
       isColouringOf(cols, CountriesRel(r)) and
       nbDistinctColours(cols, r);
