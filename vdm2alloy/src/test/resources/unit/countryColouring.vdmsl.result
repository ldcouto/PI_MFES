"module countryColouring.vdmsl\n\nopen util/relation\nopen vdmutil\n\n/************************   Country   ************************/\nsig char{}\nsig Country{\n\tx: seq char\n}\nfact CountrySet{\nall c1,c2 : Country | c1.x = c2.x implies c1=c2\n}\n\n/************************   Relation   ************************/\nsig CountryCountryProduct{\n\tfst: one Country, \n\tsnd: one Country\n}\nfact CountryCountryProductF{\nall x1,x2 : CountryCountryProduct | (x1.fst = x2.fst and x1.snd = x2.snd) implies x1=x2\n}\n\nsig setOfCountryCountry{\n\tcontentsCountryCountry: set CountryCountryProduct\n}\nfact CountryCountrySet{\nall c1,c2 : setOfCountryCountry | c1.contentsCountryCountry = c2.contentsCountryCountry implies c1 = c2\n}\n\nsig Relation in univ{}\nfact RelationInv{\nRelation = { x : setOfCountryCountry | let r = x.contentsCountryCountry | isRelation[r]  }\n}\n\n/************************   Colour   ************************/\nsig setOfCountry{\n\tcontentsCountry: set Country\n}\nfact CountrySet{\nall c1,c2 : setOfCountry | c1.contentsCountry = c2.contentsCountry implies c1 = c2\n}\n\nsig Colour in univ{}\nfact ColourInv{\nColour = { x : setOfCountry }\n}\n\n/************************   Colouring   ************************/\nsig setOfColour{\n\tcontentsColour: set Colour\n}\nfact ColourSet{\nall c1,c2 : setOfColour | c1.contentsColour = c2.contentsColour implies c1 = c2\n}\n\nsig Colouring in univ{}\nfact ColouringInv{\nColouring = { x : setOfColour }\n}\n\npred isRelation(r: Relation)\n{\tlet r = r.contentsCountryCountry | /* Body */\t\n\t( all c1 : Country, c2 : Country | \n\t\t(c1 in r.fst and c2 in r.snd implies \n\t\t\t(c1 != c2)\n\t\t)\n\t)\n\n}\n\nrun isRelation\npred areNb(cn1: Country, cn2: Country, r: Relation)\n{\tlet r = r.contentsCountryCountry | /* Body */\t\n\t(\n\t\t(cn1 in r.fst and cn2 in r.snd)\n\t or \n\t\t(cn2 in r.fst and cn1 in r.snd)\n\t)\n\n}\n\nrun areNb\nfun CountriesRel[r: Relation]: set Country\n{\tlet r = r.contentsCountryCountry | /* Body */\ttoSet[ {c1 : Country, c2 : Country | c1 in r.fst and c2 in r.snd}]\n}\n\nrun CountriesRel\npred sameColour(cn1: Country, cn2: Country, cols: Colouring)\n{\tlet cols = cols.contentsColour | /* Body */\tsome col : cols.contentsCountry | \n\t(\n\t\t(cn1 in col)\n\t and \n\t\t(cn2 in col)\n\t)\n\n}\n\nrun sameColour\nfun CountriesCol[cols: Colouring]: set Country\n{\tlet cols = cols.contentsColour | /* Body */\t\n\t(cols.contentsColour)\n\n}\n\nrun CountriesCol\npred isColouring(cols: Colouring)\n{\tlet cols = cols.contentsColour | /* Body */\t\n\t( all col1, col2 : cols.contentsCountry | \n\t\t(\n\t\t\t(col1 != col2)\n\t\t implies no \n\t\t\t(col1 & col2)\n\t\t)\n\t)\n\n}\n\nrun isColouring\npred isColouringOf(cols: Colouring, cns: set Country)\n{\tlet cols = cols.contentsColour | /* Body */\t\n\t(CountriesCol[cols]  = cns)\n\n}\n\nrun isColouringOf\npred nbDistinctColours(cols: Colouring, r: Relation)\n{\tlet cols = cols.contentsColour | let r = r.contentsCountryCountry | /* Body */\t\n\t( all cn1, cn2 : CountriesRel[r]  | \n\t\t(areNb[cn1, cn2, r]  implies not sameColour[cn1, cn2, cols] )\n\t)\n\n}\n\nrun nbDistinctColours\npred colMap(r: Relation, cols : Colouring)\n{\t /* Pre conditions */\tisRelation[r] \t /* Post conditions */\t\n\t(isColouring[cols]  and \n\t\t(isColouringOf[cols, CountriesRel[r] ]  and nbDistinctColours[cols, r] )\n\t)\n\n}\n\nrun colMap\n"